// Fibonacci sequence example in Orion
// Demonstrates recursion, loops, and different syntax styles

// Recursive fibonacci function (single-line syntax)
fibonacci_recursive(n int) -> int => n <= 1 ? n : fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)

// Iterative fibonacci function (block syntax)
fibonacci_iterative(n int) -> int {
    if n <= 1 {
        return n
    }
    
    a = 0
    b = 1
    
    for i = 2; i <= n; i++ {
        temp = a + b
        a = b
        b = temp
    }
    
    return b
}

// Function to print fibonacci sequence
print_fibonacci(count int, use_recursive bool) -> void {
    print("Fibonacci sequence (" + (use_recursive ? "recursive" : "iterative") + "):")
    
    for i = 0; i < count; i++ {
        result int
        
        if use_recursive {
            result = fibonacci_recursive(i)
        } else {
            result = fibonacci_iterative(i)
        }
        
        print("F(" + str(i) + ") = " + str(result))
    }
}

// Performance comparison
time_fibonacci(n int) -> void {
    print("\nPerformance comparison for F(" + str(n) + "):")
    
    // Time iterative version
    print("Calculating iterative...")
    result_iter = fibonacci_iterative(n)
    print("Iterative result: " + str(result_iter))
    
    // Time recursive version (only for small n to avoid long waits)
    if n <= 35 {
        print("Calculating recursive...")
        result_rec = fibonacci_recursive(n)
        print("Recursive result: " + str(result_rec))
    } else {
        print("Skipping recursive version (too slow for n > 35)")
    }
}

// Fibonacci with memoization
struct FibCache {
    cache int[100]  // Simple fixed-size cache
    size int
}

fibonacci_memoized(n int, cache FibCache*) -> int {
    if n <= 1 {
        return n
    }
    
    // Check cache
    if n < cache.size && cache.cache[n] != -1 {
        return cache.cache[n]
    }
    
    // Calculate and cache
    result = fibonacci_memoized(n - 1, cache) + fibonacci_memoized(n - 2, cache)
    
    if n < 100 {
        cache.cache[n] = result
        if n >= cache.size {
            cache.size = n + 1
        }
    }
    
    return result
}

// Initialize cache
init_cache() -> FibCache {
    cache FibCache
    cache.size = 0
    
    // Initialize cache with -1 (uncomputed)
    for i = 0; i < 100; i++ {
        cache.cache[i] = -1
    }
    
    return cache
}

// Main function
main() -> int {
    print("=== Orion Fibonacci Examples ===")
    
    // Basic examples
    print_fibonacci(10, false)  // Iterative
    print("")
    print_fibonacci(10, true)   // Recursive
    
    // Performance comparison
    time_fibonacci(30)
    
    // Memoized version
    print("\n=== Memoized Fibonacci ===")
    cache = init_cache()
    
    for i = 0; i < 15; i++ {
        result = fibonacci_memoized(i, &cache)
        print("F(" + str(i) + ") = " + str(result))
    }
    
    // Large number with memoization
    print("\nLarge Fibonacci number:")
    big_result = fibonacci_memoized(50, &cache)
    print("F(50) = " + str(big_result))
    
    return 0
}
